{"remainingRequest":"C:\\Users\\Sarun Seepun\\Desktop\\AngularProject\\SSmanager\\node_modules\\@angular-devkit\\build-optimizer\\src\\build-optimizer\\webpack-loader.js??ref--3-1!C:\\Users\\Sarun Seepun\\Desktop\\AngularProject\\SSmanager\\node_modules\\ng2-semantic-ui\\dist\\modules\\modal\\components\\modal.js","dependencies":[{"path":"C:\\Users\\Sarun Seepun\\Desktop\\AngularProject\\SSmanager\\node_modules\\ng2-semantic-ui\\dist\\modules\\modal\\components\\modal.js","mtime":1521243576000},{"path":"C:\\Users\\Sarun Seepun\\Desktop\\AngularProject\\SSmanager\\node_modules\\cache-loader\\dist\\cjs.js","mtime":1527053443986},{"path":"C:\\Users\\Sarun Seepun\\Desktop\\AngularProject\\SSmanager\\node_modules\\@angular-devkit\\build-optimizer\\src\\build-optimizer\\webpack-loader.js","mtime":1519266497000}],"contextDependencies":[],"result":["import { Component, Input, ViewChild, ElementRef, Renderer2, EventEmitter, Output, HostListener, ViewContainerRef } from \"@angular/core\";\nimport { Util, KeyCode, SuiComponentFactory } from \"../../../misc/util/index\";\nimport { TransitionController, Transition, TransitionDirection } from \"../../transition/index\";\nimport { ModalControls } from \"../classes/modal-controls\";\nimport { ModalConfig } from \"../classes/modal-config\";\nvar SuiModal = /*@__PURE__*/ (function () {\n    function SuiModal(_renderer, _element, _componentFactory) {\n        var _this = this;\n        this._renderer = _renderer;\n        this._element = _element;\n        this._componentFactory = _componentFactory;\n        // Initialise with default configuration from `ModalConfig` (to avoid writing defaults twice).\n        var config = new ModalConfig();\n        this.loadConfig(config);\n        // Event emitters for each of the possible modal outcomes.\n        this.onApprove = new EventEmitter();\n        this.onDeny = new EventEmitter();\n        this.onDismiss = new EventEmitter();\n        // Initialise controls with actions for the `approve` and `deny` cases.\n        this.controls = new ModalControls(function (res) { return _this.dismiss(function () { return _this.onApprove.emit(res); }); }, function (res) { return _this.dismiss(function () { return _this.onDeny.emit(res); }); });\n        // Internal variable initialisation.\n        this.dimBackground = false;\n        this._isClosing = false;\n        this.transitionController = new TransitionController(false);\n    }\n    Object.defineProperty(SuiModal.prototype, \"approve\", {\n        get: function () {\n            return this.controls.approve;\n        },\n        enumerable: true,\n        configurable: true\n    });\n    Object.defineProperty(SuiModal.prototype, \"deny\", {\n        get: function () {\n            return this.controls.deny;\n        },\n        enumerable: true,\n        configurable: true\n    });\n    Object.defineProperty(SuiModal.prototype, \"isFullScreen\", {\n        get: \n        // Value to deny with when closing via `isClosable`.\n        function () {\n            return this._isFullScreen;\n        },\n        set: function (fullScreen) {\n            this._isFullScreen = Util.DOM.parseBooleanAttribute(fullScreen);\n        },\n        enumerable: true,\n        configurable: true\n    });\n    Object.defineProperty(SuiModal.prototype, \"mustScroll\", {\n        get: function () {\n            return this._mustScroll;\n        },\n        set: function (mustScroll) {\n            this._mustScroll = mustScroll;\n            // 'Cache' value in _mustAlwaysScroll so that if `true`, _mustScroll isn't ever auto-updated.\n            this._mustAlwaysScroll = mustScroll;\n            this.updateScroll();\n        },\n        enumerable: true,\n        configurable: true\n    });\n    Object.defineProperty(SuiModal.prototype, \"isInverted\", {\n        get: function () {\n            return this._isInverted;\n        },\n        set: function (inverted) {\n            this._isInverted = Util.DOM.parseBooleanAttribute(inverted);\n        },\n        enumerable: true,\n        configurable: true\n    });\n    Object.defineProperty(SuiModal.prototype, \"dynamicClasses\", {\n        get: function () {\n            var classes = {};\n            if (this.size) {\n                classes[this.size] = true;\n            }\n            return classes;\n        },\n        enumerable: true,\n        configurable: true\n    });\n    SuiModal.prototype.ngOnInit = function () {\n        var _this = this;\n        // Transition the modal to be visible.\n        this.transitionController.animate(new Transition(this.transition, this.transitionDuration, TransitionDirection.In));\n        setTimeout(function () { return _this.dimBackground = true; });\n    };\n    SuiModal.prototype.ngAfterViewInit = function () {\n        var _this = this;\n        // Move the modal to the document body to ensure correct scrolling.\n        this._originalContainer = this._element.nativeElement.parentNode;\n        document.querySelector(\"body\").appendChild(this._element.nativeElement);\n        // Remove the #templateSibling element from the DOM to fix bottom border styles.\n        var templateElement = this.templateSibling.element.nativeElement;\n        if (templateElement.parentNode) {\n            templateElement.parentNode.removeChild(templateElement);\n        }\n        // Update margin offset to center modal correctly on-screen.\n        var element = this._modalElement.nativeElement;\n        setTimeout(function () {\n            _this._renderer.setStyle(element, \"margin-top\", \"-\" + element.clientHeight / 2 + \"px\");\n            _this.updateScroll();\n        });\n        // Focus any element with [autofocus] attribute.\n        var autoFocus = element.querySelector(\"[autofocus]\");\n        if (autoFocus) {\n            // Autofocus after the browser has had time to process other event handlers.\n            setTimeout(function () { return autoFocus.focus(); }, 10);\n            // Try to focus again when the modal has opened so that autofocus works in IE11.\n            setTimeout(function () { return autoFocus.focus(); }, this.transitionDuration);\n        }\n    };\n    // Updates the modal with the specified configuration.\n    // Updates the modal with the specified configuration.\n    SuiModal.prototype.loadConfig =\n        // Updates the modal with the specified configuration.\n        function (config) {\n            this.isClosable = config.isClosable;\n            this.closeResult = config.closeResult;\n            this.size = config.size;\n            this.isFullScreen = config.isFullScreen;\n            this.isBasic = config.isBasic;\n            this.isInverted = config.isInverted;\n            this.mustScroll = config.mustScroll;\n            this.transition = config.transition;\n            this.transitionDuration = config.transitionDuration;\n        };\n    // Dismisses the modal with a transition, firing the callback after the modal has finished transitioning.\n    // Dismisses the modal with a transition, firing the callback after the modal has finished transitioning.\n    SuiModal.prototype.dismiss =\n        // Dismisses the modal with a transition, firing the callback after the modal has finished transitioning.\n        function (callback) {\n            var _this = this;\n            if (callback === void 0) {\n                callback = function () { };\n            }\n            // If we aren't currently closing,\n            if (!this._isClosing) {\n                this._isClosing = true;\n                // Transition the modal to be invisible.\n                this.dimBackground = false;\n                this.transitionController.stopAll();\n                this.transitionController.animate(new Transition(this.transition, this.transitionDuration, TransitionDirection.Out, function () {\n                    // When done, move the modal back to its original location, emit a dismiss event, and fire the callback.\n                    if (_this._originalContainer) {\n                        _this._originalContainer.appendChild(_this._element.nativeElement);\n                    }\n                    _this.onDismiss.emit();\n                    callback();\n                }));\n            }\n        };\n    // Closes the modal with a 'deny' outcome, using the specified default reason.\n    // Closes the modal with a 'deny' outcome, using the specified default reason.\n    SuiModal.prototype.close =\n        // Closes the modal with a 'deny' outcome, using the specified default reason.\n        function () {\n            if (this.isClosable) {\n                // If we are allowed to close, fire the deny result with the default value.\n                this.deny(this.closeResult);\n            }\n        };\n    // Decides whether the modal needs to reposition to allow scrolling.\n    // Decides whether the modal needs to reposition to allow scrolling.\n    SuiModal.prototype.updateScroll =\n        // Decides whether the modal needs to reposition to allow scrolling.\n        function () {\n            // Semantic UI modal margin is 3.5rem, which is relative to the global font size, so for compatibility:\n            var fontSize = parseFloat(window.getComputedStyle(document.documentElement).getPropertyValue(\"font-size\"));\n            var margin = fontSize * 3.5;\n            // _mustAlwaysScroll works by stopping _mustScroll from being automatically updated, so it stays `true`.\n            if (!this._mustAlwaysScroll && this._modalElement) {\n                var element = this._modalElement.nativeElement;\n                // The modal must scroll if the window height is smaller than the modal height + both margins.\n                this._mustScroll = window.innerHeight < element.clientHeight + margin * 2;\n            }\n        };\n    SuiModal.prototype.onClick = function (e) {\n        // Makes sense here, as the modal shouldn't be attached to any DOM element.\n        e.stopPropagation();\n    };\n    // Document listener is fine here because nobody will enough modals open.\n    SuiModal.prototype.onDocumentKeyUp =\n        // Document listener is fine here because nobody will enough modals open.\n        function (e) {\n            if (e.keyCode === KeyCode.Escape) {\n                // Close automatically covers case of `!isClosable`, so check not needed.\n                this.close();\n            }\n        };\n    SuiModal.prototype.onDocumentResize = function () {\n        this.updateScroll();\n    };\n    return SuiModal;\n}());\nexport { SuiModal };\n//# sourceMappingURL=modal.js.map \n",null]}