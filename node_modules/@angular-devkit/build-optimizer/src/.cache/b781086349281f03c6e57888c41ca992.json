{"remainingRequest":"C:\\Users\\Sarun Seepun\\Desktop\\AngularProject\\SSmanager\\node_modules\\@angular-devkit\\build-optimizer\\src\\build-optimizer\\webpack-loader.js??ref--3-1!C:\\Users\\Sarun Seepun\\Desktop\\AngularProject\\SSmanager\\node_modules\\ng2-semantic-ui\\dist\\modules\\transition\\classes\\transition-controller.js","dependencies":[{"path":"C:\\Users\\Sarun Seepun\\Desktop\\AngularProject\\SSmanager\\node_modules\\ng2-semantic-ui\\dist\\modules\\transition\\classes\\transition-controller.js","mtime":1521243576000},{"path":"C:\\Users\\Sarun Seepun\\Desktop\\AngularProject\\SSmanager\\node_modules\\cache-loader\\dist\\cjs.js","mtime":1527053443986},{"path":"C:\\Users\\Sarun Seepun\\Desktop\\AngularProject\\SSmanager\\node_modules\\@angular-devkit\\build-optimizer\\src\\build-optimizer\\webpack-loader.js","mtime":1519266497000}],"contextDependencies":[],"result":["import { TransitionDirection } from \"./transition\";\r\nvar TransitionController = /*@__PURE__*/ (function () {\r\n    function TransitionController(isInitiallyVisible, display) {\r\n        if (isInitiallyVisible === void 0) {\r\n            isInitiallyVisible = true;\r\n        }\r\n        if (display === void 0) {\r\n            display = \"block\";\r\n        }\r\n        // isInitiallyVisible sets whether the element starts out visible.\r\n        this._isVisible = isInitiallyVisible;\r\n        this._isHidden = !this._isVisible;\r\n        this._display = display;\r\n        this._queue = [];\r\n        this._isAnimating = false;\r\n    }\r\n    Object.defineProperty(TransitionController.prototype, \"_isReady\", {\r\n        // Used to delay animations until we have an element to animate.\r\n        get: \r\n        // Used to delay animations until we have an element to animate.\r\n        function () {\r\n            return this._renderer != undefined && this._element != undefined && this._changeDetector != undefined;\r\n        },\r\n        enumerable: true,\r\n        configurable: true\r\n    });\r\n    Object.defineProperty(TransitionController.prototype, \"isAnimating\", {\r\n        get: function () {\r\n            return this._isAnimating;\r\n        },\r\n        enumerable: true,\r\n        configurable: true\r\n    });\r\n    Object.defineProperty(TransitionController.prototype, \"isVisible\", {\r\n        get: function () {\r\n            return this._isVisible;\r\n        },\r\n        enumerable: true,\r\n        configurable: true\r\n    });\r\n    Object.defineProperty(TransitionController.prototype, \"isHidden\", {\r\n        get: function () {\r\n            return this._isHidden;\r\n        },\r\n        enumerable: true,\r\n        configurable: true\r\n    });\r\n    Object.defineProperty(TransitionController.prototype, \"_queueFirst\", {\r\n        // Gets the first transition in the queue.\r\n        get: \r\n        // Gets the first transition in the queue.\r\n        function () {\r\n            return this._queue[0];\r\n        },\r\n        enumerable: true,\r\n        configurable: true\r\n    });\r\n    Object.defineProperty(TransitionController.prototype, \"_queueLast\", {\r\n        // Gets the last transition in the queue.\r\n        get: \r\n        // Gets the last transition in the queue.\r\n        function () {\r\n            return this._queue[this._queue.length - 1];\r\n        },\r\n        enumerable: true,\r\n        configurable: true\r\n    });\r\n    // Sets the renderer to be used for animating.\r\n    // Sets the renderer to be used for animating.\r\n    TransitionController.prototype.registerRenderer =\r\n        // Sets the renderer to be used for animating.\r\n        function (renderer) {\r\n            this._renderer = renderer;\r\n            this.performTransition();\r\n        };\r\n    // Sets the element to perform the animations on.\r\n    // Sets the element to perform the animations on.\r\n    TransitionController.prototype.registerElement =\r\n        // Sets the element to perform the animations on.\r\n        function (element) {\r\n            this._element = element;\r\n            this.performTransition();\r\n        };\r\n    // Sets the change detector to detect changes when using ChangeDetectionStrategy.OnPush.\r\n    // Sets the change detector to detect changes when using ChangeDetectionStrategy.OnPush.\r\n    TransitionController.prototype.registerChangeDetector =\r\n        // Sets the change detector to detect changes when using ChangeDetectionStrategy.OnPush.\r\n        function (changeDetector) {\r\n            this._changeDetector = changeDetector;\r\n            this.performTransition();\r\n        };\r\n    TransitionController.prototype.animate = function (transition) {\r\n        // Test if transition is one of the list that doesn't change the visible state.\r\n        // Should these eventually become classes?\r\n        var isDirectionless = [\"jiggle\", \"flash\", \"shake\", \"pulse\", \"tada\", \"bounce\"].indexOf(transition.type) !== -1;\r\n        if (isDirectionless) {\r\n            transition.direction = TransitionDirection.Static;\r\n        }\r\n        else if (transition.direction == undefined || transition.direction === TransitionDirection.Either) {\r\n            // Set the direction to the opposite of the current visible state automatically if not set, or set to either direction.\r\n            transition.direction = this._isVisible ? TransitionDirection.Out : TransitionDirection.In;\r\n            if (this._queueLast) {\r\n                // If there is an transition in the queue already, set the direction to the opposite of the direction of that transition.\r\n                if (this._queueLast.direction === TransitionDirection.In) {\r\n                    transition.direction = TransitionDirection.Out;\r\n                }\r\n                else if (this._queueLast.direction === TransitionDirection.Out) {\r\n                    transition.direction = TransitionDirection.In;\r\n                }\r\n            }\r\n        }\r\n        // Store the transition in the queue before attempting to perform it.\r\n        this._queue.push(transition);\r\n        this.performTransition();\r\n    };\r\n    TransitionController.prototype.performTransition = function () {\r\n        var _this = this;\r\n        if (!this._isReady || this._isAnimating || !this._queueFirst) {\r\n            // Don't transition until we are ready, or if we are animating, or if there aren't any transitions in the queue.\r\n            return;\r\n        }\r\n        this._isAnimating = true;\r\n        var transition = this._queueFirst;\r\n        // Set the Semantic UI classes for transitioning.\r\n        transition.classes.forEach(function (c) { return _this._renderer.addClass(_this._element, c); });\r\n        this._renderer.addClass(this._element, \"animating\");\r\n        this._renderer.addClass(this._element, transition.directionClass);\r\n        // Set the Semantic UI styles for transitioning.\r\n        this._renderer.setStyle(this._element, \"animationDuration\", transition.duration + \"ms\");\r\n        this._renderer.setStyle(this._element, \"display\", this._display);\r\n        if (transition.direction === TransitionDirection.In) {\r\n            // Unset hidden if we are transitioning in.\r\n            this._isHidden = false;\r\n        }\r\n        // Wait the length of the animation before calling the complete callback.\r\n        this._animationTimeout = window.setTimeout(function () { return _this.finishTransition(transition); }, transition.duration);\r\n    };\r\n    // Called when a transition has completed.\r\n    // Called when a transition has completed.\r\n    TransitionController.prototype.finishTransition =\r\n        // Called when a transition has completed.\r\n        function (transition) {\r\n            var _this = this;\r\n            // Unset the Semantic UI classes & styles for transitioning.\r\n            transition.classes.forEach(function (c) { return _this._renderer.removeClass(_this._element, c); });\r\n            this._renderer.removeClass(this._element, \"animating\");\r\n            this._renderer.removeClass(this._element, transition.directionClass);\r\n            this._renderer.removeStyle(this._element, \"animationDuration\");\r\n            this._renderer.removeStyle(this._element, \"display\");\r\n            if (transition.direction === TransitionDirection.In) {\r\n                // If we have just animated in, we are now visible.\r\n                this._isVisible = true;\r\n            }\r\n            else if (transition.direction === TransitionDirection.Out) {\r\n                // If we have transitioned out, we should be invisible and hidden.\r\n                this._isVisible = false;\r\n                this._isHidden = true;\r\n            }\r\n            if (transition.onComplete) {\r\n                // Call the user-defined transition callback.\r\n                transition.onComplete();\r\n            }\r\n            // Delete the transition from the queue.\r\n            this._queue.shift();\r\n            this._isAnimating = false;\r\n            this._changeDetector.markForCheck();\r\n            // Immediately attempt to perform another transition.\r\n            this.performTransition();\r\n        };\r\n    // Stops the current transition, leaves the rest of the queue intact.\r\n    // Stops the current transition, leaves the rest of the queue intact.\r\n    TransitionController.prototype.stop =\r\n        // Stops the current transition, leaves the rest of the queue intact.\r\n        function (transition) {\r\n            if (transition === void 0) {\r\n                transition = this._queueFirst;\r\n            }\r\n            if (!transition || !this._isAnimating) {\r\n                return;\r\n            }\r\n            clearTimeout(this._animationTimeout);\r\n            this.finishTransition(transition);\r\n        };\r\n    // Stops the current transition, and empties the queue.\r\n    // Stops the current transition, and empties the queue.\r\n    TransitionController.prototype.stopAll =\r\n        // Stops the current transition, and empties the queue.\r\n        function () {\r\n            this.clearQueue();\r\n            this.stop();\r\n        };\r\n    // Empties the transition queue but carries on with the current transition.\r\n    // Empties the transition queue but carries on with the current transition.\r\n    TransitionController.prototype.clearQueue =\r\n        // Empties the transition queue but carries on with the current transition.\r\n        function () {\r\n            if (this.isAnimating) {\r\n                this._queue = [this._queueFirst];\r\n                return;\r\n            }\r\n            this._queue = [];\r\n        };\r\n    return TransitionController;\r\n}());\r\nexport { TransitionController };\r\n//# sourceMappingURL=transition-controller.js.map \r\n",null]}