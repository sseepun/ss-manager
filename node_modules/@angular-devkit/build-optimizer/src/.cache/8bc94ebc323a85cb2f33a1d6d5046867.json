{"remainingRequest":"C:\\Users\\Sarun Seepun\\Desktop\\AngularProject\\SSmanager\\node_modules\\@angular-devkit\\build-optimizer\\src\\build-optimizer\\webpack-loader.js??ref--3-1!C:\\Users\\Sarun Seepun\\Desktop\\AngularProject\\SSmanager\\node_modules\\ng2-semantic-ui\\dist\\modules\\search\\services\\search.service.js","dependencies":[{"path":"C:\\Users\\Sarun Seepun\\Desktop\\AngularProject\\SSmanager\\node_modules\\ng2-semantic-ui\\dist\\modules\\search\\services\\search.service.js","mtime":1521243576000},{"path":"C:\\Users\\Sarun Seepun\\Desktop\\AngularProject\\SSmanager\\node_modules\\cache-loader\\dist\\cjs.js","mtime":1527053443986},{"path":"C:\\Users\\Sarun Seepun\\Desktop\\AngularProject\\SSmanager\\node_modules\\@angular-devkit\\build-optimizer\\src\\build-optimizer\\webpack-loader.js","mtime":1519266497000}],"contextDependencies":[],"result":["import { Util } from \"../../../misc/util/index\";\r\nvar SearchService = /*@__PURE__*/ (function () {\r\n    function SearchService(allowEmptyQuery) {\r\n        if (allowEmptyQuery === void 0) {\r\n            allowEmptyQuery = false;\r\n        }\r\n        var _this = this;\r\n        this._options = [];\r\n        this.optionsFilter = function (os, q) {\r\n            // Convert the query string to a RegExp.\r\n            var regex = _this.toRegex(_this._query);\r\n            if (regex instanceof RegExp) {\r\n                // Only update the results if the query was valid regex.\r\n                // This avoids the results suddenly becoming empty if an invalid regex string is inputted.\r\n                return os\r\n                    .filter(function (o) {\r\n                    return Util.Object.readValue(o, _this._optionsField)\r\n                        .toString()\r\n                        .match(regex);\r\n                });\r\n            }\r\n            // Don't update since it wasn't a valid regex.\r\n            return false;\r\n        };\r\n        // Set default values and reset.\r\n        this.allowEmptyQuery = allowEmptyQuery;\r\n        this.searchDelay = 0;\r\n        this.reset();\r\n    }\r\n    Object.defineProperty(SearchService.prototype, \"options\", {\r\n        get: function () {\r\n            return this._options;\r\n        },\r\n        set: function (options) {\r\n            this._options = options || [];\r\n            // We cannot use both local & remote options simultaneously.\r\n            this._optionsLookup = undefined;\r\n            // Reset entire service with new options.\r\n            this.reset();\r\n        },\r\n        enumerable: true,\r\n        configurable: true\r\n    });\r\n    Object.defineProperty(SearchService.prototype, \"optionsLookup\", {\r\n        get: function () {\r\n            return this._optionsLookup;\r\n        },\r\n        set: function (lookupFn) {\r\n            this._optionsLookup = lookupFn;\r\n            // As before, cannot use local & remote options simultaneously.\r\n            this._options = [];\r\n            this.reset();\r\n        },\r\n        enumerable: true,\r\n        configurable: true\r\n    });\r\n    Object.defineProperty(SearchService.prototype, \"hasItemLookup\", {\r\n        get: function () {\r\n            return !!this.optionsLookup && this.optionsLookup.length === 2;\r\n        },\r\n        enumerable: true,\r\n        configurable: true\r\n    });\r\n    Object.defineProperty(SearchService.prototype, \"optionsField\", {\r\n        get: function () {\r\n            return this._optionsField;\r\n        },\r\n        set: function (field) {\r\n            this._optionsField = field;\r\n            // We need to reset otherwise we would now be showing invalid search results.\r\n            this.reset();\r\n        },\r\n        enumerable: true,\r\n        configurable: true\r\n    });\r\n    Object.defineProperty(SearchService.prototype, \"results\", {\r\n        get: function () {\r\n            return this._results;\r\n        },\r\n        enumerable: true,\r\n        configurable: true\r\n    });\r\n    Object.defineProperty(SearchService.prototype, \"query\", {\r\n        get: function () {\r\n            return this._query;\r\n        },\r\n        enumerable: true,\r\n        configurable: true\r\n    });\r\n    Object.defineProperty(SearchService.prototype, \"isSearching\", {\r\n        get: function () {\r\n            return this._isSearching;\r\n        },\r\n        enumerable: true,\r\n        configurable: true\r\n    });\r\n    // Updates the query after the specified search delay.\r\n    // Updates the query after the specified search delay.\r\n    SearchService.prototype.updateQueryDelayed =\r\n        // Updates the query after the specified search delay.\r\n        function (query, callback) {\r\n            var _this = this;\r\n            if (callback === void 0) {\r\n                callback = function () { };\r\n            }\r\n            this._query = query;\r\n            clearTimeout(this._searchDelayTimeout);\r\n            this._searchDelayTimeout = window.setTimeout(function () {\r\n                _this.updateQuery(query, callback);\r\n            }, this.searchDelay);\r\n        };\r\n    // Updates the current search query.\r\n    // Updates the current search query.\r\n    SearchService.prototype.updateQuery =\r\n        // Updates the current search query.\r\n        function (query, callback) {\r\n            var _this = this;\r\n            if (callback === void 0) {\r\n                callback = function () { };\r\n            }\r\n            this._query = query;\r\n            if (this._query === \"\" && !this.allowEmptyQuery) {\r\n                // Don't update if the new query is empty (and we don't allow empty queries).\r\n                // Don't reset so that when animating closed we don't get a judder.\r\n                return callback();\r\n            }\r\n            if (this._resultsCache.hasOwnProperty(this._query)) {\r\n                // If the query is already cached, make use of it.\r\n                this._results = this._resultsCache[this._query];\r\n                return callback();\r\n            }\r\n            if (this._optionsLookup) {\r\n                this._isSearching = true;\r\n                // Call the options lookup without a this context.\r\n                var queryLookup = this._optionsLookup.call(undefined, this._query);\r\n                queryLookup\r\n                    .then(function (results) {\r\n                    _this._isSearching = false;\r\n                    _this.updateResults(results);\r\n                    return callback();\r\n                })\r\n                    .catch(function (error) {\r\n                    // Unset 'loading' state, and throw the returned error without updating the results.\r\n                    // Unset 'loading' state, and throw the returned error without updating the results.\r\n                    _this._isSearching = false;\r\n                    return callback(error);\r\n                });\r\n                return;\r\n            }\r\n            var filtered = this.optionsFilter.call(undefined, this._options, this._query);\r\n            if (filtered) {\r\n                this.updateResults(filtered);\r\n            }\r\n            return callback();\r\n        };\r\n    // Updates & caches the new set of results.\r\n    // Updates & caches the new set of results.\r\n    SearchService.prototype.updateResults =\r\n        // Updates & caches the new set of results.\r\n        function (results) {\r\n            this._resultsCache[this._query] = results;\r\n            this._results = results;\r\n        };\r\n    // tslint:disable-next-line:promise-function-async\r\n    // tslint:disable-next-line:promise-function-async\r\n    SearchService.prototype.initialLookup =\r\n        // tslint:disable-next-line:promise-function-async\r\n        function (initial) {\r\n            if (initial instanceof Array) {\r\n                return this._optionsLookup(undefined, initial);\r\n            }\r\n            return this._optionsLookup(undefined, initial);\r\n        };\r\n    // Converts a query string to regex without throwing an error.\r\n    // Converts a query string to regex without throwing an error.\r\n    SearchService.prototype.toRegex =\r\n        // Converts a query string to regex without throwing an error.\r\n        function (query) {\r\n            try {\r\n                return new RegExp(query, \"i\");\r\n            }\r\n            catch (e) {\r\n                return query;\r\n            }\r\n        };\r\n    // Generates HTML for highlighted match text.\r\n    // Generates HTML for highlighted match text.\r\n    SearchService.prototype.highlightMatches =\r\n        // Generates HTML for highlighted match text.\r\n        function (text, query) {\r\n            var regex = this.toRegex(query);\r\n            if (regex instanceof RegExp) {\r\n                return text.replace(regex, function (match) { return \"<b>\" + match + \"</b>\"; });\r\n            }\r\n            return text;\r\n        };\r\n    // Resets the search back to a pristine state.\r\n    // Resets the search back to a pristine state.\r\n    SearchService.prototype.reset =\r\n        // Resets the search back to a pristine state.\r\n        function () {\r\n            this._results = [];\r\n            this._resultsCache = {};\r\n            this._isSearching = false;\r\n            this.updateQuery(\"\");\r\n        };\r\n    return SearchService;\r\n}());\r\nexport { SearchService };\r\n//# sourceMappingURL=search.service.js.map \r\n",null]}