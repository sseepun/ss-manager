{"remainingRequest":"C:\\Users\\Sarun Seepun\\Desktop\\AngularProject\\SSmanager\\node_modules\\@angular-devkit\\build-optimizer\\src\\build-optimizer\\webpack-loader.js??ref--3-1!C:\\Users\\Sarun Seepun\\Desktop\\AngularProject\\SSmanager\\node_modules\\ng2-semantic-ui\\dist\\modules\\tabs\\components\\tabset.js","dependencies":[{"path":"C:\\Users\\Sarun Seepun\\Desktop\\AngularProject\\SSmanager\\node_modules\\ng2-semantic-ui\\dist\\modules\\tabs\\components\\tabset.js","mtime":1521243577000},{"path":"C:\\Users\\Sarun Seepun\\Desktop\\AngularProject\\SSmanager\\node_modules\\cache-loader\\dist\\cjs.js","mtime":1527053443986},{"path":"C:\\Users\\Sarun Seepun\\Desktop\\AngularProject\\SSmanager\\node_modules\\@angular-devkit\\build-optimizer\\src\\build-optimizer\\webpack-loader.js","mtime":1519266497000}],"contextDependencies":[],"result":["import { Component, ContentChildren } from \"@angular/core\";\nimport { SuiTabHeader } from \"../directives/tab-header\";\nimport { SuiTabContent } from \"../directives/tab-content\";\nimport { Tab } from \"../classes/tab\";\nvar SuiTabset = /*@__PURE__*/ (function () {\n    function SuiTabset() {\n        this.tabs = [];\n        this._barrierCount = 0;\n    }\n    Object.defineProperty(SuiTabset.prototype, \"activeTab\", {\n        get: function () {\n            return this._activeTab;\n        },\n        // When setting a tab as the currently active tab, it automatically gains\n        // `isActive` status (saves littering `isActive = true` everywhere).\n        set: \n        // When setting a tab as the currently active tab, it automatically gains\n        // `isActive` status (saves littering `isActive = true` everywhere).\n        function (tab) {\n            this._activeTab = tab;\n            tab.isActive = true;\n        },\n        enumerable: true,\n        configurable: true\n    });\n    SuiTabset.prototype.ngAfterContentInit = function () {\n        var _this = this;\n        // Fire `internalComponentsUpdated` when the query lists change.\n        this._tabHeaders.changes.subscribe(function () { return _this.internalComponentsUpdated(); });\n        this._tabContents.changes.subscribe(function () { return _this.internalComponentsUpdated(); });\n        // Initially load the tabs.\n        this.loadTabs();\n    };\n    // Fires whenever either the tab headers or tab contents query lists update.\n    // Fires whenever either the tab headers or tab contents query lists update.\n    SuiTabset.prototype.internalComponentsUpdated =\n        // Fires whenever either the tab headers or tab contents query lists update.\n        function () {\n            // We are using a 'counting barrier of n = 2', i.e. the code within only runs after the method is called twice.\n            // This is so that both the headers and contents query lists can update before we run code that matches the two up.\n            this._barrierCount++;\n            if (this._barrierCount === 2) {\n                // Reset the barrier so it can be called again.\n                this._barrierCount = 0;\n                // Update the tabs.\n                this.loadTabs();\n            }\n        };\n    // Connects tab headers to tab contents, and creates a tab instance for each pairing.\n    // Connects tab headers to tab contents, and creates a tab instance for each pairing.\n    SuiTabset.prototype.loadTabs =\n        // Connects tab headers to tab contents, and creates a tab instance for each pairing.\n        function () {\n            var _this = this;\n            // Remove any tabs that no longer have an associated header.\n            this.tabs = this.tabs.filter(function (t) { return !!_this._tabHeaders.find(function (tH) { return tH === t.header; }); });\n            this._tabHeaders\n                .filter(function (tH) { return !_this.tabs.find(function (t) { return t.header === tH; }); })\n                .forEach(function (tH) {\n                var content = _this._tabContents.find(function (tC) { return tC.id === tH.id; });\n                if (!content) {\n                    // Error if an associated tab content cannot be found for the given header.\n                    throw new Error(\"A [suiTabHeader] must have a related [suiTabContent].\");\n                }\n                // Create a new tab instance for this header & content combo.\n                var tab = new Tab(tH, content);\n                // Subscribe to any external changes in the tab header's active state. External changes are triggered by user input.\n                tab.header.isActiveExternalChange.subscribe(function () { return _this.onHeaderActiveChanged(tab); });\n                // Add the new instance to the list of tabs.\n                // Add the new instance to the list of tabs.\n                _this.tabs.push(tab);\n            });\n            // Assign each tab an index (which denotes the order they physically appear in).\n            this._tabHeaders\n                .forEach(function (tH, i) {\n                var tab = _this.tabs.find(function (t) { return t.header === tH; });\n                if (tab) {\n                    tab.index = i;\n                }\n            });\n            // Sort the tabs by their index.\n            this.tabs.sort(function (a, b) { return a.index - b.index; });\n            if (!this.activeTab) {\n                // Check if there are no current existing active tabs.\n                // If so, we must activate the first available tab.\n                this.activateFirstTab();\n            }\n            else if (!this.tabs.find(function (t) { return t === _this.activeTab; })) {\n                // O'wise check if current active tab has been deleted.\n                // If so, we must find the closest.\n                // Use `setTimeout` as this causes a 'changed after checked' error o'wise.\n                setTimeout(function () { return _this.activateClosestTab(_this.activeTab); });\n            }\n            if (this.tabs.length === 0) {\n                // Error if there aren't any tabs in the tabset.\n                throw new Error(\"You cannot have no tabs!\");\n            }\n        };\n    // Fires whenever a tab header's active state is externally changed.\n    // Fires whenever a tab header's active state is externally changed.\n    SuiTabset.prototype.onHeaderActiveChanged =\n        // Fires whenever a tab header's active state is externally changed.\n        function (tab) {\n            // If the tab has become activated, but was not previously the active tab:\n            if (tab.isActive && this.activeTab !== tab) {\n                // Deactivate all of the tabs.\n                this.tabs.filter(function (t) { return t !== tab; }).forEach(function (t) { return t.isActive = false; });\n                // Set the currently active tab to this one.\n                this.activeTab = tab;\n            }\n            // If the tab has become deactivated, but was previously the active tab:\n            if (!tab.isActive && this.activeTab === tab) {\n                // Activate the closest tab to it.\n                this.activateClosestTab(tab);\n            }\n        };\n    // Activate the first tab in the set.\n    // Activate the first tab in the set.\n    SuiTabset.prototype.activateFirstTab =\n        // Activate the first tab in the set.\n        function () {\n            this.activeTab = this.tabs[0];\n        };\n    // Activates the closest available tab to a given one.\n    // Activates the closest available tab to a given one.\n    SuiTabset.prototype.activateClosestTab =\n        // Activates the closest available tab to a given one.\n        function (tab) {\n            var nextAvailable;\n            // When the exited tab's index is higher than all available tabs,\n            if (tab.index >= this.tabs.length) {\n                // Activate the last tab.\n                nextAvailable = this.tabs[this.tabs.length - 1];\n            }\n            // If that didn't work, try the following cases:\n            if (!nextAvailable) {\n                if (!this.tabs.find(function (t) { return t === tab; })) {\n                    // When the exited tab no longer exists,\n                    // Replace it with a tab at the same index.\n                    nextAvailable = this.tabs[tab.index];\n                }\n                else {\n                    // Or if the exited tab still exists,\n                    // Go to the tab immediately to the left.\n                    nextAvailable = this.tabs[Math.max(tab.index - 1, 0)];\n                }\n            }\n            // However, if the chosen tab is disabled,\n            if (nextAvailable.isDisabled) {\n                // Activate the closest available tab to it.\n                return this.activateClosestTab(nextAvailable);\n            }\n            this.activeTab = nextAvailable;\n        };\n    return SuiTabset;\n}());\nexport { SuiTabset };\n//# sourceMappingURL=tabset.js.map \n",null]}