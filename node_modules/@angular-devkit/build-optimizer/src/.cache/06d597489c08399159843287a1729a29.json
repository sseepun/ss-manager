{"remainingRequest":"C:\\Users\\Sarun Seepun\\Desktop\\AngularProject\\SSmanager\\node_modules\\@angular-devkit\\build-optimizer\\src\\build-optimizer\\webpack-loader.js??ref--3-1!C:\\Users\\Sarun Seepun\\Desktop\\AngularProject\\SSmanager\\node_modules\\ng2-semantic-ui\\dist\\modules\\select\\components\\multi-select.js","dependencies":[{"path":"C:\\Users\\Sarun Seepun\\Desktop\\AngularProject\\SSmanager\\node_modules\\ng2-semantic-ui\\dist\\modules\\select\\components\\multi-select.js","mtime":1521243576000},{"path":"C:\\Users\\Sarun Seepun\\Desktop\\AngularProject\\SSmanager\\node_modules\\cache-loader\\dist\\cjs.js","mtime":1527053443986},{"path":"C:\\Users\\Sarun Seepun\\Desktop\\AngularProject\\SSmanager\\node_modules\\@angular-devkit\\build-optimizer\\src\\build-optimizer\\webpack-loader.js","mtime":1519266497000}],"contextDependencies":[],"result":["var __extends = (this && this.__extends) || (function () {\n    var extendStatics = Object.setPrototypeOf ||\n        ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||\n        function (d, b) { for (var p in b)\n            if (b.hasOwnProperty(p))\n                d[p] = b[p]; };\n    return function (d, b) {\n        extendStatics(d, b);\n        function __() { this.constructor = d; }\n        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n    };\n})();\nimport { Component, HostBinding, ElementRef, EventEmitter, Output, Input, Directive, Renderer2 } from \"@angular/core\";\nimport { KeyCode, customValueAccessorFactory, CustomValueAccessor } from \"../../../misc/util/index\";\nimport { SuiLocalizationService } from \"../../../behaviors/localization/index\";\nimport { SuiSelectBase } from \"../classes/select-base\";\nvar SuiMultiSelect = /*@__PURE__*/ (function (_super) {\n    __extends(SuiMultiSelect, _super);\n    function SuiMultiSelect(element, renderer, localizationService) {\n        var _this = _super.call(this, element, renderer, localizationService) || this;\n        _this.selectedOptions = [];\n        _this.selectedOptionsChange = new EventEmitter();\n        _this.hasLabels = true;\n        _this._multiSelectClasses = true;\n        return _this;\n    }\n    Object.defineProperty(SuiMultiSelect.prototype, \"filteredOptions\", {\n        get: function () {\n            var _this = this;\n            if (this.maxSelectedReached) {\n                // If we have reached the maximum number of selections, then empty the results completely.\n                return [];\n            }\n            var searchResults = this.searchService.results;\n            if (!this.hasLabels) {\n                return searchResults;\n            }\n            else {\n                // Returns the search results \\ selected options.\n                return searchResults\n                    .filter(function (r) { return _this.selectedOptions.find(function (o) { return r === o; }) == undefined; });\n            }\n        },\n        enumerable: true,\n        configurable: true\n    });\n    Object.defineProperty(SuiMultiSelect.prototype, \"availableOptions\", {\n        get: function () {\n            return this.filteredOptions;\n        },\n        enumerable: true,\n        configurable: true\n    });\n    Object.defineProperty(SuiMultiSelect.prototype, \"hasLabels\", {\n        get: function () {\n            return this._hasLabels;\n        },\n        set: function (hasLabels) {\n            this._hasLabels = hasLabels;\n        },\n        enumerable: true,\n        configurable: true\n    });\n    Object.defineProperty(SuiMultiSelect.prototype, \"placeholder\", {\n        get: function () {\n            return this._placeholder || this.localeValues.multi.placeholder;\n        },\n        set: function (placeholder) {\n            this._placeholder = placeholder;\n        },\n        enumerable: true,\n        configurable: true\n    });\n    Object.defineProperty(SuiMultiSelect.prototype, \"maxSelectedReached\", {\n        get: function () {\n            if (this.maxSelected == undefined) {\n                // If there is no maximum then we can immediately return.\n                return false;\n            }\n            return this.selectedOptions.length === this.maxSelected;\n        },\n        enumerable: true,\n        configurable: true\n    });\n    Object.defineProperty(SuiMultiSelect.prototype, \"maxSelectedMessage\", {\n        get: function () {\n            return this._localizationService.interpolate(this.localeValues.multi.maxSelectedMessage, [[\"max\", this.maxSelected.toString()]]);\n        },\n        enumerable: true,\n        configurable: true\n    });\n    Object.defineProperty(SuiMultiSelect.prototype, \"selectedMessage\", {\n        get: function () {\n            return this._localizationService.interpolate(this.localeValues.multi.selectedMessage, [[\"count\", this.selectedOptions.length.toString()]]);\n        },\n        enumerable: true,\n        configurable: true\n    });\n    SuiMultiSelect.prototype.optionsUpdateHook = function () {\n        var _this = this;\n        if (!this._writtenOptions && this.selectedOptions.length > 0) {\n            // We need to check the options still exist.\n            this.writeValue(this.selectedOptions.map(function (o) { return _this.valueGetter(o); }));\n        }\n        if (this._writtenOptions && this.searchService.options.length > 0) {\n            // If there were values written by ngModel before the options had been loaded, this runs to fix it.\n            this.selectedOptions = this._writtenOptions\n                .map(function (v) { return _this.findOption(_this.searchService.options, v); })\n                .filter(function (v) { return v != undefined; });\n            if (this.selectedOptions.length === this._writtenOptions.length) {\n                this._writtenOptions = undefined;\n            }\n        }\n    };\n    SuiMultiSelect.prototype.initialiseRenderedOption = function (option) {\n        _super.prototype.initialiseRenderedOption.call(this, option);\n        // Boldens the item so it appears selected in the dropdown.\n        option.isActive = !this.hasLabels && this.selectedOptions.indexOf(option.value) !== -1;\n    };\n    SuiMultiSelect.prototype.selectOption = function (option) {\n        var _this = this;\n        if (this.selectedOptions.indexOf(option) !== -1) {\n            this.deselectOption(option);\n            return;\n        }\n        this.selectedOptions.push(option);\n        this.selectedOptionsChange.emit(this.selectedOptions.map(function (o) { return _this.valueGetter(o); }));\n        this.resetQuery(false);\n        // Automatically refocus the search input for better keyboard accessibility.\n        this.focus();\n        if (!this.hasLabels) {\n            this.onAvailableOptionsRendered();\n        }\n    };\n    SuiMultiSelect.prototype.writeValue = function (values) {\n        var _this = this;\n        if (values instanceof Array) {\n            if (this.searchService.options.length > 0) {\n                // If the options have already been loaded, we can immediately match the ngModel values to options.\n                this.selectedOptions = values\n                    .map(function (v) { return _this.findOption(_this.searchService.options, v); })\n                    .filter(function (v) { return v != undefined; });\n            }\n            if (values.length > 0 && this.selectedOptions.length === 0) {\n                if (this.valueField && this.searchService.hasItemLookup) {\n                    // If the search service has a selected lookup function, make use of that to load the initial values.\n                    this.searchService\n                        .initialLookup(values)\n                        .then(function (items) { return _this.selectedOptions = items; });\n                }\n                else {\n                    // Otherwise, cache the written value for when options are set.\n                    this._writtenOptions = values;\n                }\n            }\n            if (values.length === 0) {\n                this.selectedOptions = [];\n            }\n        }\n        else {\n            this.selectedOptions = [];\n        }\n    };\n    SuiMultiSelect.prototype.deselectOption = function (option) {\n        var _this = this;\n        // Update selected options to the previously selected options \\ {option}.\n        this.selectedOptions = this.selectedOptions.filter(function (so) { return so !== option; });\n        this.selectedOptionsChange.emit(this.selectedOptions.map(function (o) { return _this.valueGetter(o); }));\n        // Automatically refocus the search input for better keyboard accessibility.\n        this.focus();\n        if (!this.hasLabels) {\n            this.onAvailableOptionsRendered();\n        }\n    };\n    SuiMultiSelect.prototype.onQueryInputKeydown = function (event) {\n        if (event.keyCode === KeyCode.Backspace && this.query === \"\" && this.selectedOptions.length > 0) {\n            // Deselect the rightmost option when the user presses backspace in the search input.\n            this.deselectOption(this.selectedOptions[this.selectedOptions.length - 1]);\n        }\n    };\n    return SuiMultiSelect;\n}(SuiSelectBase));\nexport { SuiMultiSelect };\n// Value accessor directive for the select to support ngModel.\nvar SuiMultiSelectValueAccessor = /*@__PURE__*/ (function (_super) {\n    __extends(SuiMultiSelectValueAccessor, _super);\n    function SuiMultiSelectValueAccessor(host) {\n        return _super.call(this, host) || this;\n    }\n    return SuiMultiSelectValueAccessor;\n}(CustomValueAccessor));\nexport { SuiMultiSelectValueAccessor };\n//# sourceMappingURL=multi-select.js.map \n",null]}